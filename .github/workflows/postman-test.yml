name: Post-Deployment Tests
# ‚úÖ This workflow is triggered automatically after the 'Manual Deploy by Tag' workflow completes successfully.
on:
  workflow_run:
    workflows: ["Manual Deploy by Tag"]
    types:
      - completed

jobs:
  run-postman-tests:
    # ‚úÖ Only run this job if the triggering deployment workflow was successful.
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to checkout code and update release notes

    steps:
      - name: "üì• Get data from triggering workflow"
        id: get_data
        run: |
          # The run name is "Deploy [environment] by tag tag_name"
          # We parse this string to get the environment and tag for this test run.
          RUN_NAME="${{ github.event.workflow_run.name }}"
          echo "Parsing run name: $RUN_NAME"
          
          # Extract environment (e.g., 'uat' or 'prod')
          ENV=$(echo "$RUN_NAME" | sed -n 's/.*\[\([^]]*\)\].*/\1/p')
          echo "Extracted environment: $ENV"
          
          # Extract tag (e.g., 'v1.2.3')
          TAG=$(echo "$RUN_NAME" | sed 's/.*by tag //')
          echo "Extracted tag: $TAG"
          
          # Set the URL_DOMAIN based on the environment
          if [ "$ENV" = "uat" ]; then
            URL_DOMAIN="https://uat.mamamia.com.au"
          elif [ "$ENV" = "prod" ]; then
            URL_DOMAIN="https://www.mamamia.com.au"
          else
            echo "‚ùå Could not determine a valid environment from run name."
            exit 1
          fi
          echo "Determined URL_DOMAIN: $URL_DOMAIN"

          # Set outputs for subsequent steps
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "url_domain=$URL_DOMAIN" >> $GITHUB_OUTPUT

      - name: "Checkout code for tag: ${{ steps.get_data.outputs.tag }}"
        uses: actions/checkout@v4
        with:
          # Use the head_sha from the completed workflow run to ensure we test the exact code that was deployed.
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: "Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: "Install Postman CLI"
        run: |
          curl -o- "https://dl-cli.pstmn.io/install/linux64.sh" | sh

      - name: "‚ñ∂Ô∏è Run API Tests (mm-api-test)"
        run: |
          postman collection run postman/mm-api-test.postman_collection.json \
              --env-var "URL_DOMAIN=${{ steps.get_data.outputs.url_domain }}" \
              --reporters cli,html,json --reporter-html-export api-test-report.html \
              --reporter-json-export api-test-report.json || true
          

      - name: "‚ñ∂Ô∏è Run Page Tests (mm-page-test)"
        run: |
          # The command will fail if tests fail, so we add `|| true` to allow the workflow to continue to the reporting step.
          postman collection run postman/mm-page-test.postman_collection.json \
            --env-var "URL_DOMAIN=${{ steps.get_data.outputs.url_domain }}" \
            --reporters cli,html,json --reporter-html-export mm-page-test-report.html \
            --reporter-json-export mm-page-test-report.json || true

      - name: "üìé Attach Report & Update Release Notes"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TZ: Australia/Sydney
        run: |
          TAG=${{ steps.get_data.outputs.tag }}
          ENV=${{ steps.get_data.outputs.environment }}
          NOW=$(date +"%Y-%m-%d %H:%M:%S %Z")

          # Check if a release exists for the tag
          if ! release_json=$(gh api repos/${{ github.repository }}/releases/tags/$TAG 2>/dev/null); then
            echo "‚ÑπÔ∏è No release found for tag $TAG. Skipping report processing."
            exit 0
          fi
          
          echo "‚úÖ Release found for tag $TAG. Processing test reports."
          
          # 1. Upload both HTML reports as release assets
          gh release upload $TAG ./mm-page-test-report.html --clobber
          gh release upload $TAG ./api-test-report.html --clobber
          
          release_id=$(echo "$release_json" | jq -r .id)
          current_body=$(echo "$release_json" | jq -r .body)

          # 2. Extract values from the mm-page-test JSON report
          echo "üìÑ Extracting values from mm-page-test-report.json..."
          if [ -f mm-page-test-report.json ]; then
            MM_PAGES_TOTAL_TESTS=$(jq '.run.summary.tests.executed' mm-page-test-report.json)
            MM_PAGES_FAILED_TESTS=$(jq '.run.summary.tests.failed'   mm-page-test-report.json)
            MM_PAGES_PASSED_TESTS=$(jq '.run.summary.tests.passed'   mm-page-test-report.json)
          else
            MM_PAGES_TOTAL_TESTS=0; MM_PAGES_FAILED_TESTS=0; MM_PAGES_PASSED_TESTS=0
          fi

          # 3. Extract values from the api-test JSON report
          echo "üìÑ Extracting values from api-test-report.json..."
          if [ -f api-test-report.json ]; then
            MM_API_TOTAL_TESTS=$(jq '.run.summary.tests.executed' api-test-report.json)
            MM_API_FAILED_TESTS=$(jq '.run.summary.tests.failed'   api-test-report.json)
            MM_API_PASSED_TESTS=$(jq '.run.summary.tests.passed'   api-test-report.json)
          else
            MM_API_TOTAL_TESTS=0; MM_API_FAILED_TESTS=0; MM_API_PASSED_TESTS=0
          fi

          # 4. Conditionally format the summary for MM-PAGES
          if [ -n "$MM_PAGES_FAILED_TESTS" ] && [ "$MM_PAGES_FAILED_TESTS" -gt 0 ]; then
            SUMMARY_BODY_PAGES="**‚ùå MM-PAGES test failed! : TOTAL ${MM_PAGES_TOTAL_TESTS} PASSED ${MM_PAGES_PASSED_TESTS} FAILED ${MM_PAGES_FAILED_TESTS}"
          else
            SUMMARY_BODY_PAGES="**‚úÖ MM-PAGES test passed! : TOTAL ${MM_PAGES_TOTAL_TESTS} PASSED ${MM_PAGES_PASSED_TESTS} FAILED ${MM_PAGES_FAILED_TESTS}"
          fi

          # 5. Conditionally format the summary for MM-API
          if [ -n "$MM_API_FAILED_TESTS" ] && [ "$MM_API_FAILED_TESTS" -gt 0 ]; then
            SUMMARY_BODY_API="**‚ùå MM-API test failed!: TOTAL ${MM_API_TOTAL_TESTS} PASSED ${MM_API_PASSED_TESTS} FAILED ${MM_API_FAILED_TESTS}"
          else
            SUMMARY_BODY_API="**‚úÖ MM-API test passed! : TOTAL ${MM_API_TOTAL_TESTS} PASSED ${MM_API_PASSED_TESTS} FAILED ${MM_API_FAILED_TESTS}"
          fi

          # 6. Create the new entry for the release notes
          new_entry=$(cat <<EOF

          ---
          ### ü§ñ Post-Deployment Test Results
          <small>
          - **Environment:** ${ENV^^}
          - **Test Date:** ${NOW}
          - **Workflow Run:** [View Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          </small>

          ${SUMMARY_BODY_PAGES}
          ${SUMMARY_BODY_API}

          **üìÑ View the full Postman test reports:**
          - [mm-page-test-report.html](${{ github.server_url }}/${{ github.repository }}/releases/download/${TAG}/mm-page-test-report.html)
          - [api-test-report.html](${{ github.server_url }}/${{ github.repository }}/releases/download/${TAG}/api-test-report.html)
          EOF
          )

          # Combine the existing release notes with the new entry
          updated_body="${current_body}${new_entry}"

          # Use the GitHub API to update the release body by piping a JSON payload.
          # This is more reliable for multi-line strings and special characters.
          jq -n --arg body "$updated_body" '{body: $body}' | gh api \
            --method PATCH \
            -H "Accept: application/vnd.github.v3+json" \
            /repos/${{ github.repository }}/releases/$release_id \
            --input -

          echo "‚úÖ Attached Postman test reports and updated release notes for $TAG."